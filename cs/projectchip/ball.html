<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ball Chip</title>
<link rel="shortcut icon" href="img/chip_adult_happy.png" type="image/x-icon">
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    font-family: Arial, sans-serif;
    background: linear-gradient(to bottom, #6b8e23, #a2d149); /* lighter forest theme */
  }
  #hud {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-size: 24px;
    text-shadow: 2px 2px 5px black;
  }
</style>
</head>
<body>

<div id="hud">Score: 0 | Lives: 3 | High Score: 0</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

const ballImg = new Image();
ballImg.src = 'img/chip_adult_happy.png';

let score = 0;
let lives = 3;
let highScore = localStorage.getItem('highScore') || 0;

let paddle = {
  width: canvas.width*0.15,
  height: canvas.height*0.02,
  x: canvas.width/2 - canvas.width*0.075,
  y: canvas.height - canvas.height*0.05,
  dx: 0,
  speed: 10,
  color: '#654321'
};

let balls = [{
  x: canvas.width/2,
  y: canvas.height*0.7,
  width: canvas.width*0.05,
  height: canvas.width*0.05,
  dx: 4,
  dy: -4
}];

const brickRowCount = 5;
const brickColumnCount = 12;
let bricks = [];
const brickPadding = 5;
const brickOffsetTop = 60;
const brickOffsetLeft = 30;
const brickWidth = (canvas.width - brickOffsetLeft*2 - brickPadding*(brickColumnCount-1)) / brickColumnCount;
const brickHeight = canvas.height*0.04;

for(let r=0;r<brickRowCount;r++){
  bricks[r]=[];
  for(let c=0;c<brickColumnCount;c++){
    bricks[r][c] = { x:0, y:0, status:1, color:`hsl(${Math.random()*40+100},50%,50%)`};
  }
}

let powerups = [];
const powerupTypes = [
  {icon:'ðŸ€', type:'multiBall'},
  {icon:'ðŸŸ©', type:'bigPaddle'},
  {icon:'ðŸŸ¥', type:'smallPaddle'},
  {icon:'âš¡', type:'fastBall'},
  {icon:'ðŸŒ', type:'slowBall'}
];

document.addEventListener('keydown', e=>{if(e.key==='ArrowLeft')paddle.dx=-paddle.speed;if(e.key==='ArrowRight')paddle.dx=paddle.speed;});
document.addEventListener('keyup', e=>{if(e.key==='ArrowLeft'||e.key==='ArrowRight')paddle.dx=0;});

function maybeSpawnPowerup(x,y){
  if(Math.random()<0.1){
    const p = powerupTypes[Math.floor(Math.random()*powerupTypes.length)];
    powerups.push({x:x, y:y, size:40, dy:2, type:p.type, icon:p.icon});
  }
}

function activatePowerup(type){
  switch(type){
    case 'multiBall':
      let newBalls = balls.map(b=>({x:b.x,y:b.y,width:b.width,height:b.height,dx:-b.dx,dy:b.dy}));
      balls.push(...newBalls);
      break;
    case 'bigPaddle':
      paddle.width*=1.5;
      setTimeout(()=>{paddle.width/=1.5;},10000);
      break;
    case 'smallPaddle':
      paddle.width/=1.5;
      setTimeout(()=>{paddle.width*=1.5;},10000);
      break;
    case 'fastBall':
      balls.forEach(b=>{b.dx*=1.5;b.dy*=1.5;});
      setTimeout(()=>{balls.forEach(b=>{b.dx/=1.5;b.dy/=1.5;});},10000);
      break;
    case 'slowBall':
      balls.forEach(b=>{b.dx*=0.7;b.dy*=0.7;});
      setTimeout(()=>{balls.forEach(b=>{b.dx/=0.7;b.dy/=0.7;});},10000);
      break;
  }
}

function paddleCollision(ball){
  if(ball.y + ball.height > paddle.y &&
     ball.x + ball.width > paddle.x &&
     ball.x < paddle.x + paddle.width){
    ball.dy = -Math.abs(ball.dy);
    ball.y = paddle.y - ball.height;
    score += 1;
  }
}

function brickCollision(ball){
  for(let r=0;r<brickRowCount;r++){
    for(let c=0;c<brickColumnCount;c++){
      const b = bricks[r][c];
      if(b.status){
        if(ball.x + ball.width > b.x && ball.x < b.x + brickWidth &&
           ball.y + ball.height > b.y && ball.y < b.y + brickHeight){
          ball.dy *= -1;
          b.status = 0;
          score += 10;
          maybeSpawnPowerup(b.x+brickWidth/2, b.y+brickHeight/2);
        }
      }
    }
  }
}

function ballsCollision(){
  for(let i=0;i<balls.length;i++){
    for(let j=i+1;j<balls.length;j++){
      const b1=balls[i], b2=balls[j];
      const dx = b2.x-b1.x, dy=b2.y-b1.y;
      const dist = Math.hypot(dx,dy);
      if(dist < b1.width/2 + b2.width/2){
        [b1.dx,b2.dx] = [b2.dx,b1.dx];
        [b1.dy,b2.dy] = [b2.dy,b1.dy];
      }
    }
  }
}

function update(){
  balls.forEach((ball,i)=>{
    ball.x += ball.dx;
    ball.y += ball.dy;

    if(ball.x < 0 || ball.x + ball.width > canvas.width) ball.dx *= -1;
    if(ball.y < 0) ball.dy *= -1;
    if(ball.y > canvas.height){
      balls.splice(i,1);
      if(balls.length===0){
        lives--;
        if(lives>0){
          balls.push({x:canvas.width/2, y:canvas.height*0.7, width:canvas.width*0.05, height:canvas.width*0.05, dx:4, dy:-4});
        } else {
          if(score>highScore){highScore=score;localStorage.setItem('highScore',highScore);}
          score=0; lives=3;
          balls.push({x:canvas.width/2, y:canvas.height*0.7, width:canvas.width*0.05, height:canvas.width*0.05, dx:4, dy:-4});
          bricks.forEach(row=>row.forEach(b=>b.status=1));
        }
      }
    }

    paddleCollision(ball);
    brickCollision(ball);
  });

  ballsCollision();

  paddle.x += paddle.dx;
  if(paddle.x < 0) paddle.x = 0;
  if(paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

  powerups.forEach((p,i)=>{
    p.y += p.dy;
    if(p.y + p.size > paddle.y && p.x > paddle.x && p.x < paddle.x + paddle.width){
      activatePowerup(p.type);
      powerups.splice(i,1);
    }
    if(p.y > canvas.height) powerups.splice(i,1);
  });

  document.getElementById('hud').textContent=`Score: ${score} | Lives: ${lives} | High Score: ${highScore}`;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for(let r=0;r<brickRowCount;r++){
    for(let c=0;c<brickColumnCount;c++){
      const b=bricks[r][c];
      if(b.status){
        b.x = brickOffsetLeft + c*(brickWidth+brickPadding);
        b.y = brickOffsetTop + r*(brickHeight+brickPadding);
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x,b.y,brickWidth,brickHeight);
        ctx.strokeStyle = '#333';
        ctx.strokeRect(b.x,b.y,brickWidth,brickHeight);
      }
    }
  }

  balls.forEach(ball=>{
    ctx.drawImage(ballImg, ball.x, ball.y, ball.width, ball.height);
  });

  ctx.fillStyle = paddle.color;
  ctx.fillRect(paddle.x,paddle.y,paddle.width,paddle.height);

  ctx.font = '40px Arial';
  powerups.forEach(p=>{
    ctx.fillText(p.icon, p.x, p.y);
  });
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

ballImg.onload = ()=>{ loop(); };
</script>

</body>
</html>
